<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>面试1.java基础 |  vsty’s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-面试1-java基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试1.java基础
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/14/%E9%9D%A2%E8%AF%951-java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-02-13T16:00:45.000Z" itemprop="datePublished">2020-02-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">5.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">22 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1-JDK-和-JRE有什么区别："><a href="#1-JDK-和-JRE有什么区别：" class="headerlink" title="1.JDK 和 JRE有什么区别："></a>1.JDK 和 JRE有什么区别：</h3><p>jdk面向开发人员，jre面向运行人员</p>
<p> <img src="https://img-blog.csdnimg.cn/20190914142941228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fMDA2,size_16,color_FFFFFF,t_70" alt="img"> </p>
<h3 id="2-和equal的区别："><a href="#2-和equal的区别：" class="headerlink" title="2.==和equal的区别："></a>2.==和equal的区别：</h3><p>equal要求引用的对象内容相同即可，==要求引用也相同</p>
<p>所以比较字符串是否相等，一般用equal</p>
<p>equal还可以重载自定义</p>
<span id="more"></span>

<h3 id="3-两个对象的hashcode（）相同，则equal（）也一定为true吗？"><a href="#3-两个对象的hashcode（）相同，则equal（）也一定为true吗？" class="headerlink" title="3.两个对象的hashcode（）相同，则equal（）也一定为true吗？"></a>3.两个对象的hashcode（）相同，则equal（）也一定为true吗？</h3><p>不一定，这两个方法都可以重载，但是一般相等，可以提高哈希表的性能</p>
<h3 id="4-final在java中有什么用？"><a href="#4-final在java中有什么用？" class="headerlink" title="4.final在java中有什么用？"></a>4.final在java中有什么用？</h3><p>在匿名内部类中有时被使用</p>
<p>1.修饰变量：不能被更改</p>
<p>2.修饰方法：不能被重写覆盖</p>
<p>3.修饰类：不能被继承（少用）</p>
<h3 id="5-java中Math-round（-1-5）等于多少？"><a href="#5-java中Math-round（-1-5）等于多少？" class="headerlink" title="5.java中Math.round（-1.5）等于多少？"></a>5.java中Math.round（-1.5）等于多少？</h3><p> Math的round方法是四舍五入,如果参数是负数,则往大的数如,Math.round(-1.5)=-1，如果是Math.round(1.5)则结果为2</p>
<p>（自己看源码）</p>
<h3 id="6-String属于基础的数据类型吗？"><a href="#6-String属于基础的数据类型吗？" class="headerlink" title="6.String属于基础的数据类型吗？"></a>6.String属于基础的数据类型吗？</h3><p>不是，但是是用final修饰的。不可以改变</p>
<h3 id="7-java中操作字符串都有哪些类？它们都有什么区别？"><a href="#7-java中操作字符串都有哪些类？它们都有什么区别？" class="headerlink" title="7.java中操作字符串都有哪些类？它们都有什么区别？"></a>7.java中操作字符串都有哪些类？它们都有什么区别？</h3><p> <img src="https://img-blog.csdnimg.cn/20190902164048107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU4ODYw,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20190902163952840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU4ODYw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20190902163911944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU4ODYw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p>我们先来看这几个接口究竟是什么样？</p>
<h6 id="1-interface-Serializable"><a href="#1-interface-Serializable" class="headerlink" title="1.interface Serializable"></a>1.interface Serializable</h6><p>这是一个空指针，仅仅标识可序列化的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSerial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;user.txt&quot;</span>));</span><br><span class="line">            objectOutputStream.writeObject(user);</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromSerial</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;user.txt&quot;</span>));</span><br><span class="line">            User user = (User) objectInputStream.readObject();</span><br><span class="line">            objectInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。 </p>
<p> 那么什么情况下需要序列化呢?大概有这样两类比较常见的场景：</p>
<p>1)、需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时;</p>
<p>2)、网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时; </p>
<p> 在反序列化的过程中则需要使用serialVersionUID来确定由哪个类来加载这个对象 。</p>
<p> <img src="https://pics2.baidu.com/feed/7aec54e736d12f2e74a189fae941286684356808.jpeg?token=8db9c3d747a2c165271fec8acab06dcf&s=18205D32190A4449144974DA0000D0B2" alt="img"> </p>
<p> Transient 关键字的作用是控制变量的序列化 </p>
<h6 id="2-interface-Comparable"><a href="#2-interface-Comparable" class="headerlink" title="2.interface Comparable"></a>2.interface Comparable<T></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line"><span class="comment">//该接口对实现它的每个类的对象强加一个整体排序。 这个排序被称为类的自然排序 ，类的compareTo方法被称为其自然比较方法 。</span></span><br></pre></td></tr></table></figure>

<p> &lt;T extends Comparable<T>&gt; : 它代表的意思是：类型T必须实现Comparable接口，并且这个接口的类型是T。这样，T的实例之间才能相互比较大小。</p>
<p>&lt;T extends Comparable&lt;? super T&gt;&gt;　:类型T必须实现Comparable接口，并且这个接口的类型是T或者是T的任一父类。这样声明后，T的实例之间和T的父类的实例之间可以相互比较大小。</p>
<h6 id="3-interface-CharSequence"><a href="#3-interface-CharSequence" class="headerlink" title="3.interface CharSequence"></a>3.interface CharSequence</h6><p> JDK1.8中为了加强接口的能力，使得接口可以存在具体的方法，前提是方法需要被default或static关键字所修饰。 </p>
<p>woc，这下interface流弊了，不仅又静态方法，还有可以被实现类继承和重写的方法。</p>
<p>再看源码之前，先来看一看java中BaseStream（流）的概念</p>
<p> <img src="https://img-blog.csdn.net/20180718155721781?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeGlhb2J1YWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param</span> T : the type of the stream elements 流中的元素类型</span><br><span class="line"></span><br><span class="line"><span class="meta">@Param</span> S : the type of of the stream implementing 流中的实现类型</span><br><span class="line"></span><br><span class="line">BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt;</span><br></pre></td></tr></table></figure>

<p> 这里就是支持两个类型T和S，T随便什么类，但S一定要是继承自己的类。比如IntSteam，T就是Interger，S则可以是IntStream、LongStream、DoubleStream </p>
<p>以下是BaseStream的方法列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isParallel</span><span class="params">()</span></span>; <span class="comment">//判断是否是并行化流</span></span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">sequential</span><span class="params">()</span></span>; <span class="comment">//将流串行化</span></span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">parallel</span><span class="params">()</span></span>; <span class="comment">//将流并行化</span></span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">unordered</span><span class="params">()</span></span>;  <span class="comment">//解除有序流的顺序限制，发挥并行处理的性能优势</span></span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">onClose</span><span class="params">(Runnable closeHandler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于流以后再研究，这里篇幅有限😁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> IntStream <span class="title">chars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CharIterator</span> <span class="keyword">implements</span> <span class="title">PrimitiveIterator</span>.<span class="title">OfInt</span> </span>&#123;</span><br><span class="line">     <span class="comment">//再挖个坑，有空研究一下Iterator的源码和它的子接口以及实现类       </span></span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur &lt; length();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> charAt(cur++);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(IntConsumer block)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (; cur &lt; length(); cur++) &#123;</span><br><span class="line">                    block.accept(charAt(cur));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(() -&gt;</span><br><span class="line">                Spliterators.spliterator(</span><br><span class="line">                        <span class="keyword">new</span> CharIterator(),</span><br><span class="line">                        length(),</span><br><span class="line">                        Spliterator.ORDERED),</span><br><span class="line">                Spliterator.SUBSIZED | Spliterator.SIZED | Spliterator.ORDERED,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> IntStream <span class="title">codePoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CodePointIterator</span> <span class="keyword">implements</span> <span class="title">PrimitiveIterator</span>.<span class="title">OfInt</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(IntConsumer block)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = length();</span><br><span class="line">                <span class="keyword">int</span> i = cur;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">                        <span class="keyword">char</span> c1 = charAt(i++);</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isHighSurrogate(c1) || i &gt;= length) &#123;</span><br><span class="line">                            block.accept(c1);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">char</span> c2 = charAt(i);</span><br><span class="line">                            <span class="keyword">if</span> (Character.isLowSurrogate(c2)) &#123;</span><br><span class="line">                                i++;</span><br><span class="line">                                block.accept(Character.toCodePoint(c1, c2));</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                block.accept(c1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cur = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur &lt; length();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = length();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur &gt;= length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> c1 = charAt(cur++);</span><br><span class="line">                <span class="keyword">if</span> (Character.isHighSurrogate(c1) &amp;&amp; cur &lt; length) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c2 = charAt(cur);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isLowSurrogate(c2)) &#123;</span><br><span class="line">                        cur++;</span><br><span class="line">                        <span class="keyword">return</span> Character.toCodePoint(c1, c2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(() -&gt;</span><br><span class="line">                Spliterators.spliteratorUnknownSize(</span><br><span class="line">                        <span class="keyword">new</span> CodePointIterator(),</span><br><span class="line">                        Spliterator.ORDERED),</span><br><span class="line">                Spliterator.ORDERED,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-interface-Appendable"><a href="#4-interface-Appendable" class="headerlink" title="4.interface Appendable"></a>4.interface Appendable</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">Appendable <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h5 id="接下来我们看一下StringBuffer和StringBuilder的源码："><a href="#接下来我们看一下StringBuffer和StringBuilder的源码：" class="headerlink" title="接下来我们看一下StringBuffer和StringBuilder的源码："></a>接下来我们看一下StringBuffer和StringBuilder的源码：</h5><p>追加的方法实际上都是调用父类的追加方法,但是StringBuffer类中多了一行toStringCache = null;的代码,其中toStringCache是一个char[];这个属性在重写toString()方法中使用了 </p>
<p>String类型的字符串是不可变的,对String类型的字符床做修改操作都是相当于重新创建对象。</p>
<p>而对StringBuffer和StringBuilder进行增删操作都是对同一个对象做操作。</p>
<p>StringBuffer中的方法大部分都使用synchronized关键字修饰,所以StringBuffer是线程安全的。</p>
<p>StringBuilder中的方法则没有,线程不安全。</p>
<p>但是StringBuilder因为没有使用使用synchronized关键字修饰,所以性能更高,在单线程环境下我会选择使用StringBuilder,多线程环境下使用StringBuffer.</p>
<p>如果生命的这个字符串几乎不做修改操作,那么我就直接使用String,因为不调用new关键字声明String类型的变量的话它不会在堆内存中创建对象,直接指向String的常量池,并且可以复用.效率更高.</p>
<p>——————————————————————————————————</p>
<h3 id="8-String-str-”i”与String-str-new-String（“i”）一样吗？"><a href="#8-String-str-”i”与String-str-new-String（“i”）一样吗？" class="headerlink" title="8.String str=”i”与String str=new String（“i”）一样吗？"></a>8.String str=”i”与String str=new String（“i”）一样吗？</h3><p>string是final的，前者str1和str2都是指向常量池的同一个区域</p>
<p>后者str1和str2指向堆中不一样的对象</p>
<h3 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h3><p>1.二分递归反转（substring）</p>
<p>2.使用charAt，for循环拼接（或者转化为char数组也可以）</p>
<p>3.StringBuffer.reverse().toString();</p>
<p>4.利用栈</p>
<p>5.对称调换法</p>
<h3 id="10-String类的常用方法有哪些？"><a href="#10-String类的常用方法有哪些？" class="headerlink" title="10.String类的常用方法有哪些？"></a>10.String类的常用方法有哪些？</h3><ul>
<li>equals：字符串是否相同</li>
<li>equalsIgnoreCase：忽略大小写后字符串是否相同</li>
<li>compareTo：根据字符串中每个字符的Unicode编码进行比较</li>
<li>compareToIgnoreCase：根据字符串中每个字符的Unicode编码进行忽略大小写比较</li>
<li>indexOf：目标字符或字符串在源字符串中位置下标</li>
<li>lastIndexOf：目标字符或字符串在源字符串中最后一次出现的位置下标</li>
<li>valueOf：其他类型转字符串</li>
<li>charAt：获取指定下标位置的字符</li>
<li>codePointAt：指定下标的字符的Unicode编码</li>
<li>concat：追加字符串到当前字符串</li>
<li>isEmpty：字符串长度是否为0</li>
<li>contains：是否包含目标字符串</li>
<li>startsWith：是否以目标字符串开头</li>
<li>endsWith：是否以目标字符串结束</li>
<li>format：格式化字符串</li>
<li>getBytes：获取字符串的字节数组</li>
<li>getChars：获取字符串的指定长度字符数组</li>
<li>toCharArray：获取字符串的字符数组</li>
<li>join：以某字符串，连接某字符串数组</li>
<li>length：字符串字符数</li>
<li>matches：字符串是否匹配正则表达式</li>
<li>replace：字符串替换</li>
<li>replaceAll：带正则字符串替换</li>
<li>replaceFirst：替换第一个出现的目标字符串</li>
<li>split：以某正则表达式分割字符串</li>
<li>substring：截取字符串</li>
<li>toLowerCase：字符串转小写</li>
<li>toUpperCase：字符串转大写</li>
<li>trim：去字符串首尾空格</li>
</ul>
<h3 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h3><p>可以，但这个类不能被实例化</p>
<h3 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h3><p> 如果一个类包含抽象方法，那么该类必须是抽象类 </p>
<h3 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13.抽象类能使用final修饰吗？"></a>13.抽象类能使用final修饰吗？</h3><p>显然不能，如果不能继承，那抽象了干嘛，有病吗？</p>
<h3 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h3><p>接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。</p>
<p>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>
<p> 接口可继承接口，并可多继承接口，但类只能单根继承。 </p>
<h3 id="15-java的IO流分为几种？"><a href="#15-java的IO流分为几种？" class="headerlink" title="15.java的IO流分为几种？"></a>15.java的IO流分为几种？</h3><p> <img src="https://img-blog.csdnimg.cn/20190518162733826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDI2ODA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p>•InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>•OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<p>常见场景：</p>
<p>1.利用字符流文件IO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="comment">//读、写都会发生IO异常</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1：创建一个字符输出流对象，用于操作文件。该对象一建立，就必须明确数据存储位置，是一个文件。</span></span><br><span class="line"><span class="comment">    2：对象产生后，会在堆内存中有一个实体，同时也调用了系统底层资源，在指定的位置创建了一个存储数据的文件。</span></span><br><span class="line"><span class="comment">    3：如果指定位置，出现了同名文件，文件会被覆盖。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;demo.txt&quot;</span>); <span class="comment">// FileNotFoundException</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用Writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。怎么把数据弄到文件中？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fw.write(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">    fw.flush(); <span class="comment">// 刷新缓冲区，将缓冲区中的数据刷到目的地文件中。</span></span><br><span class="line">    fw.close(); <span class="comment">// 关闭流，其实关闭的就是java调用的系统底层资源。在关闭前，会先刷新该流。</span></span><br></pre></td></tr></table></figure>

<p>采用 FileWriter和FileReader的·IO效率比较低。</p>
<p>一般采用BufferWriter和BufferReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\bw.txt&quot;</span>));            		bw.write(<span class="string">&quot;高效O Demo&quot;</span>);            </span><br><span class="line">bw.write(<span class="string">&quot;换\r\n行&quot;</span>);            </span><br><span class="line">bw.flush();            </span><br><span class="line">bw.close();        </span><br><span class="line">特殊功能：            </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 写一个换行符，具体是什么由系统决定， win(\r\n)   linux(\n)   mac(\r) </span></span></span><br></pre></td></tr></table></figure>

<p> 文件高效写入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\bw.txt&quot;</span>));            </span><br><span class="line">String line;            </span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;                </span><br><span class="line">       System.out.println(line);</span><br><span class="line">&#125;                        </span><br><span class="line">br.close; </span><br></pre></td></tr></table></figure>

<p>2.使用字节流拷贝文件：（也可以使用字符流，甚至用缓冲流提高字符流的IO效率）</p>
<p> 拥有缓冲区的流被称为缓冲流，包括BufferedInputStream、 BufferedOutputStream类和BufferedReader、BufferedWriter类。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream out=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//新建一个文件目录</span></span><br><span class="line">            File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\JSP\\ycc.java&quot;</span>);</span><br><span class="line">            <span class="comment">//创建新文件，但是目录要自己创建，</span></span><br><span class="line">            file.createNewFile();</span><br><span class="line">            <span class="comment">//构造输入流，从哪里读取数据</span></span><br><span class="line">            in=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\WiFi_Log.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//构造输出流，前面输入流的读取的数据输出到新文件</span></span><br><span class="line">            out=<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            <span class="comment">//通过逐个读取，存入字节，实现文件拷贝</span></span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.对象的序列化（上面已经写过）</p>
<p>序列化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void readObj() throws Exception&#123;</span><br><span class="line">        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\obj.txt&quot;));</span><br><span class="line">        Object obj=ois.readObject();</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>反序列化：</p>
<pre><code>public static void writeObj() throws Exception&#123;
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\obj.txt&quot;));
    oos.writeObject(new Person(&quot;zhangsan&quot;,25));
    oos.close();
&#125;
</code></pre>
<h3 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16.BIO、NIO、AIO有什么区别？"></a>16.BIO、NIO、AIO有什么区别？</h3><p>BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。<br>NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。<br>AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。<br> ————————</p>
<p>BIO是一个连接一个线程。<br>NIO是一个请求一个线程。<br>AIO是一个有效请求一个线程。<br> ————————</p>
<p>BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<br>适用场景分析</p>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<p>————————</p>
<p>要理解上面的话首先需要理解几个概念：</p>
<h4 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1.线程与进程"></a>1.线程与进程</h4><p> 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. </p>
<p> 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 </p>
<h4 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2.同步与异步"></a>2.同步与异步</h4><p> 同步：例如：B/S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 </p>
<p>异步： 当这个调用完成后，<strong>一般通过状态、通知和回调来通知调用者</strong>。对于异步调用，调用的返回并不受调用者控制。 </p>
<p>​     </p>
<table>
<thead>
<tr>
<th>三种异步返回方式：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>状态：</td>
<td>轮询，效率很低</td>
</tr>
<tr>
<td>通知：</td>
<td>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</td>
</tr>
<tr>
<td>回调：</td>
<td>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</td>
</tr>
</tbody></table>
<p>看到这里又黑人问号脸，通知是告知调用者，回调是调用函数，这两者又有什么区别呢？</p>
<p>研究了一下通知（回传）：发现主要有四种方式</p>
<table>
<thead>
<tr>
<th>四种通知方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>一. 使用QueryString变量</td>
<td>QueryString是一种非常简单也是使用比较多的一种传值方式，但是它将传递的值显示在浏览器的地址栏中,如果是传递一个或多个安全性要求不高或是结构简单的数值时，可以使用这个方法。<br/><br/>Response.Redirect( “target.aspx?param1=hello&para;m2=hi “)<br/><br/>接收页面： string str = Request.QueryString[“param1”];<br/><br/>string str1 = Request.QueryString[“param2];</td>
</tr>
<tr>
<td>二.使用Cookie对象变量(Cookie是存放在客户端的)</td>
<td>设置Cookie: HttpCookie cookie_name = new HttpCookie(“name”);<br/><br/>cookie_name.Value = Label1.Text;<br/><br/>Reponse.AppendCookie(cookie_name);<br/><br/>获取Cookie:<br/><br/>string name= Request.Cookie[“name”].Value.ToString();</td>
</tr>
<tr>
<td>三. 使用Session变量(session是存放在服务器端的)</td>
<td>设置Session: Session[“name”] =”hello”;<br/><br/>获取Session: string name = Session[“name”].ToString();</td>
</tr>
<tr>
<td>四.使用Application 对象变量</td>
<td>Application对象的作用范围是整个全局，也就是说对所有用户都有效。此种方法不常使用，因为Application在一个应用程序域范围共享，所有用户可以改变及设置其值，故只应用计数器等需要全局变量的地方。<br/><br/>设置Application : Application[“name”] = =”hello”;<br/><br/>获取Application : string name = Application[“name”].ToString();</td>
</tr>
</tbody></table>
<p>起始，只是顺序执行，然后抽象出过程函数，这个抽象出来的东西是阻塞的，肯定要得到结果才处理。然后，出然了回调，不阻塞，直接返回，约定结果通过另一个方法提交返回。这个过程就是回调。 </p>
<h4 id="3-阻塞与非阻塞"><a href="#3-阻塞与非阻塞" class="headerlink" title="3.阻塞与非阻塞"></a>3.阻塞与非阻塞</h4><p>sychronized可以让临界区资源，一次只能被一个线程访问，从而结果正确。</p>
<p>阻塞和非阻塞通常被用来形容多线程间的相互影响。当一个线程占用了临界区资源，那么其它需要使用这个资源的线程都必须在这个临界区上等待。等待会导致线程挂起，这样就形成了阻塞。如果占用资源的线程一直没有释放资源，那么其它的线程在这个临界区上都不能继续工作。</p>
<p>相反，非阻塞表明多个线程之间的执行是不会相互影响的。</p>
<p> 我们使用synchronized关键字，ReentrantLock（重入锁）时，我们得到的线程就是阻塞线程。阻塞线程在执行代码前，都会尝试得到临界区资源的锁，如果得不到，线程就会一直挂起，直到临界区资源释放。 </p>
<h4 id="4-并发与并行"><a href="#4-并发与并行" class="headerlink" title="4.并发与并行"></a>4.并发与并行</h4><p> 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。 </p>
<p>![](面试1-java基础/FireShot Capture 002 - 15分钟读懂进程线程、同步异步、阻塞非阻塞、并发并行 - mhq_martin - 博客园 - <a target="_blank" rel="noopener" href="http://www.cnblogs.com.png/">www.cnblogs.com.png</a>)</p>
<p>多线程的效率和异步其实差不多，但多线程实际上是实现异步的一种方式。</p>
<p> 终极办法是并行计算，并且每个cpu下进行异步计算，这样你的每个核都充分利用。 </p>
<p>同步异步体现在要不要时刻关注任务有没有完成</p>
<p>阻塞非阻塞体现在这段时间内，能不能做其他任务</p>
<p>异步非阻塞效率最高</p>
<h4 id="5-线程锁-进程锁-分布式锁"><a href="#5-线程锁-进程锁-分布式锁" class="headerlink" title="5.线程锁-进程锁-分布式锁"></a>5.线程锁-进程锁-分布式锁</h4><p> 当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。 </p>
<p> 范围大小:分布式锁 &gt; 进程锁 &gt; 线程锁。 </p>
<p> 优点:保证资源同步<br>缺点:有等待肯定会慢 </p>
<p>——————</p>
<p>BIO是一个连接一个线程。 同步阻塞  ，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 </p>
<p>NIO是一个请求一个线程。 同步非阻塞 ， 即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 </p>
<p>AIO是一个有效请求一个线程。 异步非阻塞 ， 客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， </p>
<ul>
<li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
</li>
<li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
</li>
<li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<p>——————</p>
</li>
</ul>
<p>同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</p>
<p>同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。</p>
<p>异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</p>
<p> 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。 </p>
<h3 id="18-Files的常用方法都有哪些？"><a href="#18-Files的常用方法都有哪些？" class="headerlink" title="18.Files的常用方法都有哪些？"></a>18.Files的常用方法都有哪些？</h3><p>Files.exists()                      检测文件路径是否存在<br>Files.createFile()               创建文件<br>Files.createDirectory()    创建文件夹<br>Files.delete()                     删除文件或者目录<br>Files.copy()                        复制文件<br>Files.move()                      移动文件<br>Files.size（）                    查看文件个数<br>Files.read()                        读取文件<br>Files.write()                       写入文件</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://china-sty.github.io/2020/02/14/%E9%9D%A2%E8%AF%951-java%E5%9F%BA%E7%A1%80/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/02/15/leetcode%E8%AE%B0%E5%BD%95-1/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            leetcode记录(1)
          
        </div>
      </a>
    
    
      <a href="/2020/02/12/SpringBoot%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SpringBoot框架总结</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> vsty
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="vsty’s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/plans">计划</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>